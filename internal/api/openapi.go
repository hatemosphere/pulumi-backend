package api

import (
	"github.com/danielgtaylor/huma/v2"
	"github.com/danielgtaylor/huma/v2/adapters/humachi"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// BuildOpenAPISpec constructs the OpenAPI spec by creating a temporary huma API,
// registering all operations, and converting to kin-openapi format for tests.
func BuildOpenAPISpec() *openapi3.T {
	// Create a temporary server with dummy values.
	s := &Server{
		defaultOrg:       "organization",
		defaultUser:      "user",
		deltaCutoffBytes: 1024 * 1024,
		historyPageSize:  10,
	}

	// Create a temporary chi router and huma API.
	r := chi.NewRouter()
	api := humachi.New(r, newHumaConfig())

	// Register all operations (this populates the OpenAPI spec).
	s.registerCapabilities(api)
	s.registerUser(api)
	s.registerStacks(api)
	s.registerSecrets(api)
	s.registerUpdates(api)
	s.registerHistory(api)
	s.registerAdmin(api)

	// Downgrade from OpenAPI 3.1 to 3.0 for kin-openapi compatibility.
	// Huma generates 3.1 (uses "type": ["string","null"]), but kin-openapi
	// expects 3.0 format ("nullable": true).
	specJSON, err := api.OpenAPI().Downgrade()
	if err != nil {
		panic("failed to downgrade huma OpenAPI spec: " + err.Error())
	}

	// Load via kin-openapi for compatibility with existing tests.
	loader := openapi3.NewLoader()
	doc, err := loader.LoadFromData(specJSON)
	if err != nil {
		panic("failed to load huma spec into kin-openapi: " + err.Error())
	}

	// Note: We skip kin-openapi Validate() here because huma generates certain
	// extensions (e.g. contentMediaType for RawBody) that kin-openapi's 3.0
	// validator doesn't recognize. The spec is auto-generated by huma and
	// trustworthy. The compliance test compares schemas structurally.
	return doc
}

// HumaOpenAPISpec returns the raw huma OpenAPI spec (for programmatic access).
func HumaOpenAPISpec(api huma.API) *huma.OpenAPI {
	return api.OpenAPI()
}
