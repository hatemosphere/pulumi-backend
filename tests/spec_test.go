package tests

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"testing"

	"github.com/getkin/kin-openapi/openapi3"

	"github.com/hatemosphere/pulumi-backend/internal/api"
)

// TestOpenAPISpecSelfConsistency validates that our generated OpenAPI spec loads
// correctly and has the expected structure. The spec is auto-generated by huma,
// so strict 3.0 validation is skipped (huma extensions like contentMediaType
// are valid in 3.1 but not recognized by kin-openapi's 3.0 validator).
func TestOpenAPISpecSelfConsistency(t *testing.T) {
	spec := api.BuildOpenAPISpec()

	// Verify it has paths.
	if spec.Paths.Len() == 0 {
		t.Fatal("our OpenAPI spec has no paths")
	}

	// Count operations.
	opCount := 0
	for _, pathItem := range spec.Paths.Map() {
		for _, op := range pathItem.Operations() {
			_ = op
			opCount++
		}
	}
	t.Logf("Our OpenAPI spec: %d paths, %d operations", spec.Paths.Len(), opCount)
}

// TestAPISpecCoverage compares our generated OpenAPI spec against the official Pulumi
// Cloud OpenAPI 3.0 spec. Run with -v to see the full coverage report.
//
// To download the spec:
//
//	curl -o pulumi-spec.json https://api.pulumi.com/api/openapi/pulumi-spec.json
func TestAPISpecCoverage(t *testing.T) {
	specPath := filepath.Join("..", "pulumi-spec.json")
	if _, err := os.Stat(specPath); os.IsNotExist(err) {
		t.Skip("pulumi-spec.json not found; download with: curl -o pulumi-spec.json https://api.pulumi.com/api/openapi/pulumi-spec.json")
	}

	// --- Parse upstream Pulumi Cloud spec ---
	loader := openapi3.NewLoader()
	upstream, err := loader.LoadFromFile(specPath)
	if err != nil {
		t.Fatalf("load upstream spec: %v", err)
	}

	// --- Build our spec ---
	ours := api.BuildOpenAPISpec()

	// --- Collect endpoints from both specs ---
	upstreamSet := collectEndpoints(upstream)
	ourSet := collectEndpoints(ours)

	// --- Compare ---
	var matched, ourOnly, specOnly []string
	for ep := range ourSet {
		if upstreamSet[ep] {
			matched = append(matched, ep)
		} else {
			ourOnly = append(ourOnly, ep)
		}
	}
	for ep := range upstreamSet {
		if !ourSet[ep] {
			specOnly = append(specOnly, ep)
		}
	}
	sort.Strings(matched)
	sort.Strings(ourOnly)
	sort.Strings(specOnly)

	// --- Categorize unimplemented spec endpoints ---
	groups := make(map[string][]string)
	for _, ep := range specOnly {
		cat := categorizeEndpoint(ep)
		groups[cat] = append(groups[cat], ep)
	}

	type catEntry struct {
		name      string
		count     int
		endpoints []string
	}
	sorted := make([]catEntry, 0, len(groups))
	for cat, eps := range groups {
		sorted = append(sorted, catEntry{cat, len(eps), eps})
	}
	sort.Slice(sorted, func(i, j int) bool {
		iPlan := strings.HasPrefix(sorted[i].name, "NOT PLANNED")
		jPlan := strings.HasPrefix(sorted[j].name, "NOT PLANNED")
		if iPlan != jPlan {
			return !iPlan // gaps first, then not-planned
		}
		return sorted[i].count > sorted[j].count
	})

	// --- Report ---
	var b strings.Builder
	fmt.Fprint(&b, "\n")
	fmt.Fprint(&b, "Pulumi API Spec Coverage Report\n")
	fmt.Fprintf(&b, "Upstream: %s v%s\n", upstream.Info.Title, upstream.Info.Version)
	fmt.Fprintf(&b, "Ours:     %s v%s\n", ours.Info.Title, ours.Info.Version)
	fmt.Fprint(&b, strings.Repeat("=", 60)+"\n\n")

	fmt.Fprintf(&b, "  Upstream endpoints: %d\n", len(upstreamSet))
	fmt.Fprintf(&b, "  Our endpoints:     %d\n", len(ourSet))
	fmt.Fprintf(&b, "  Matched:           %d / %d (%.1f%% of upstream)\n",
		len(matched), len(upstreamSet), float64(len(matched))/float64(len(upstreamSet))*100)
	fmt.Fprintf(&b, "  Ours not in spec:  %d\n", len(ourOnly))
	fmt.Fprintf(&b, "  Not implemented:   %d\n\n", len(specOnly))

	// Implemented & in upstream spec.
	fmt.Fprintf(&b, "IMPLEMENTED (in upstream spec) — %d endpoints\n", len(matched))
	fmt.Fprint(&b, strings.Repeat("-", 60)+"\n")
	for _, ep := range matched {
		fmt.Fprintf(&b, "  [x] %s\n", ep)
	}

	// Implemented but not in upstream spec (our extensions / undocumented CLI endpoints).
	fmt.Fprintf(&b, "\nIMPLEMENTED (not in upstream spec) — %d endpoints\n", len(ourOnly))
	fmt.Fprint(&b, strings.Repeat("-", 60)+"\n")
	for _, ep := range ourOnly {
		fmt.Fprintf(&b, "  [+] %s\n", ep)
	}

	// Unimplemented by category.
	fmt.Fprintf(&b, "\nNOT IMPLEMENTED — %d endpoints by category\n", len(specOnly))
	fmt.Fprint(&b, strings.Repeat("-", 60)+"\n")

	notPlannedTotal := 0
	gapTotal := 0
	for _, g := range sorted {
		marker := "    "
		if !strings.HasPrefix(g.name, "NOT PLANNED") {
			marker = " !! "
			gapTotal += g.count
		} else {
			notPlannedTotal += g.count
		}
		fmt.Fprintf(&b, "%s[%3d] %s\n", marker, g.count, g.name)
	}

	fmt.Fprintf(&b, "\n  Potential gaps:  %d endpoints\n", gapTotal)
	fmt.Fprintf(&b, "  Not planned:     %d endpoints\n", notPlannedTotal)
	fmt.Fprint(&b, "\n")

	t.Log(b.String())

	// Log gap details if present.
	if gapTotal > 0 {
		var gapDetails strings.Builder
		fmt.Fprint(&gapDetails, "potential gaps in core protocol:\n")
		for _, g := range sorted {
			if strings.HasPrefix(g.name, "NOT PLANNED") {
				continue
			}
			fmt.Fprintf(&gapDetails, "\n  %s:\n", g.name)
			for _, ep := range g.endpoints {
				fmt.Fprintf(&gapDetails, "    - %s\n", ep)
			}
		}
		t.Log(gapDetails.String())
	}
}

// TestAPISpecSchemaCompliance does a detailed schema-level comparison of each matched
// endpoint between our spec and the upstream Pulumi Cloud spec. For each endpoint it
// compares parameters, request body properties, and response body properties.
func TestAPISpecSchemaCompliance(t *testing.T) {
	specPath := filepath.Join("..", "pulumi-spec.json")
	if _, err := os.Stat(specPath); os.IsNotExist(err) {
		t.Skip("pulumi-spec.json not found; download with: curl -o pulumi-spec.json https://api.pulumi.com/api/openapi/pulumi-spec.json")
	}

	loader := openapi3.NewLoader()
	upstream, err := loader.LoadFromFile(specPath)
	if err != nil {
		t.Fatalf("load upstream spec: %v", err)
	}
	ours := api.BuildOpenAPISpec()

	// We only compare endpoints that use a single update kind as a representative,
	// since all 4 kinds (preview/update/refresh/destroy) share the same schema.
	// The upstream spec defines them separately, so we pick "update" as the canonical kind.
	representativeKind := "update"

	var b strings.Builder
	fmt.Fprint(&b, "\n")
	fmt.Fprint(&b, "Detailed Schema Compliance Report\n")
	fmt.Fprint(&b, strings.Repeat("=", 70)+"\n\n")

	totalDiffs := 0
	matchedPaths := 0

	for path, upstreamItem := range upstream.Paths.Map() {
		ourItem := ours.Paths.Find(path)
		if ourItem == nil {
			continue
		}

		for method, upstreamOp := range upstreamItem.Operations() {
			ourOp := getOperation(ourItem, method)
			if ourOp == nil {
				continue
			}

			// For update-kind endpoints, only compare the "update" kind as representative.
			if strings.Contains(path, "/{updateID}") &&
				!strings.Contains(path, "/"+representativeKind+"/") {
				continue
			}

			matchedPaths++
			endpoint := strings.ToUpper(method) + " " + path

			var diffs []string //nolint:prealloc // accumulated from multiple sources

			// Compare parameters.
			diffs = append(diffs, compareParameters(upstreamOp, ourOp)...)

			// Compare request body.
			diffs = append(diffs, compareRequestBody(upstreamOp, ourOp)...)

			// Compare responses.
			diffs = append(diffs, compareResponses(upstreamOp, ourOp)...)

			if len(diffs) > 0 {
				totalDiffs += len(diffs)
				fmt.Fprintf(&b, "  %s\n", endpoint)
				for _, d := range diffs {
					fmt.Fprintf(&b, "    %s\n", d)
				}
				fmt.Fprint(&b, "\n")
			}
		}
	}

	fmt.Fprintf(&b, "Compared %d matched operations, found %d differences\n", matchedPaths, totalDiffs)

	// Categorized summary.
	var (
		singleTenant   int // Properties from multi-tenant/SaaS features
		shapeMismatch  int // Response envelope/wrapper differences
		typeMismatch   int // Type serialization differences (e.g., byte encoding)
		missingRequest int // Request fields we don't parse
		missingOptQP   int // Optional query params we don't support
		extraProps     int // Properties we return that upstream doesn't define
		otherGaps      int // Other functional gaps
	)
	// Re-scan diffs for categorization.
	for path, upstreamItem := range upstream.Paths.Map() {
		ourItem := ours.Paths.Find(path)
		if ourItem == nil {
			continue
		}
		for method, upstreamOp := range upstreamItem.Operations() {
			ourOp := getOperation(ourItem, method)
			if ourOp == nil {
				continue
			}
			if strings.Contains(path, "/{updateID}") &&
				!strings.Contains(path, "/"+representativeKind+"/") {
				continue
			}
			allDiffs := compareParameters(upstreamOp, ourOp)
			allDiffs = append(allDiffs, compareRequestBody(upstreamOp, ourOp)...)
			allDiffs = append(allDiffs, compareResponses(upstreamOp, ourOp)...)
			for _, d := range allDiffs {
				switch {
				case strings.Contains(d, "missing (optional) query"):
					missingOptQP++
				case strings.Contains(d, "type mismatch"):
					typeMismatch++
				case strings.Contains(d, "extra property") || strings.Contains(d, "extra "):
					extraProps++
				case strings.Contains(d, "[request] MISSING") || strings.Contains(d, "[request] missing"):
					missingRequest++
				case strings.Contains(d, "[response] MISSING"):
					if isSingleTenantProperty(d) {
						singleTenant++
					} else if isShapeMismatch(d, path) {
						shapeMismatch++
					} else {
						otherGaps++
					}
				case strings.Contains(d, "[response] missing"):
					singleTenant++
				default:
					otherGaps++
				}
			}
		}
	}

	fmt.Fprint(&b, "\nDifference Summary by Category\n")
	fmt.Fprint(&b, strings.Repeat("-", 50)+"\n")
	fmt.Fprintf(&b, "  Multi-tenant/SaaS (not applicable): %d\n", singleTenant)
	fmt.Fprintf(&b, "  Missing request fields:             %d\n", missingRequest)
	fmt.Fprintf(&b, "  Missing optional query params:      %d\n", missingOptQP)
	fmt.Fprintf(&b, "  Type mismatches:                    %d\n", typeMismatch)
	fmt.Fprintf(&b, "  Response shape mismatches:          %d\n", shapeMismatch)
	fmt.Fprintf(&b, "  Extra properties (ours only):       %d\n", extraProps)
	fmt.Fprintf(&b, "  Other gaps:                         %d\n", otherGaps)

	t.Log(b.String())
}

// isSingleTenantProperty returns true if a MISSING response property is expected
// to be absent in a single-tenant backend (e.g., user identity fields, SaaS features).
func isSingleTenantProperty(diff string) bool {
	singleTenantProps := []string{
		"email", "hasMFA", "id", "identities", "isManagedByMultiOrg",
		"isOrgManaged", "tokenInfo", "config", "currentOperation",
		"githubCommitInfo", "policyPacks", "requestedByToken",
		"latestDevVersion", "environment", "encryptedKey",
		"encryptionSalt", "secretsProvider", "Messages",
	}
	for _, prop := range singleTenantProps {
		if strings.Contains(diff, fmt.Sprintf("%q", prop)) {
			return true
		}
	}
	return false
}

// isShapeMismatch returns true if a MISSING response property indicates a
// response envelope/wrapper difference rather than a missing feature.
func isShapeMismatch(diff, path string) bool {
	// getUpdateByVersion and getLatestUpdate return different response shapes.
	if strings.Contains(path, "/updates/") {
		shapeProps := []string{"info", "latestVersion", "requestedBy", "updateID", "version"}
		for _, prop := range shapeProps {
			if strings.Contains(diff, fmt.Sprintf("%q", prop)) {
				return true
			}
		}
	}
	return false
}

// getOperation returns the operation for a given method on a PathItem.
func getOperation(item *openapi3.PathItem, method string) *openapi3.Operation {
	switch strings.ToUpper(method) {
	case "GET":
		return item.Get
	case "POST":
		return item.Post
	case "PUT":
		return item.Put
	case "PATCH":
		return item.Patch
	case "DELETE":
		return item.Delete
	case "HEAD":
		return item.Head
	}
	return nil
}

// compareParameters compares path and query parameters between upstream and ours.
func compareParameters(upstream, ours *openapi3.Operation) []string {
	var diffs []string

	upParams := make(map[string]*openapi3.Parameter)
	for _, p := range upstream.Parameters {
		if p.Value != nil {
			upParams[p.Value.In+":"+p.Value.Name] = p.Value
		}
	}

	ourParams := make(map[string]*openapi3.Parameter)
	for _, p := range ours.Parameters {
		if p.Value != nil {
			ourParams[p.Value.In+":"+p.Value.Name] = p.Value
		}
	}

	// Parameters in upstream but not in ours.
	for key, upParam := range upParams {
		ourParam, ok := ourParams[key]
		if !ok {
			severity := "MISSING"
			if !upParam.Required {
				severity = "missing (optional)"
			}
			diffs = append(diffs, fmt.Sprintf("[param] %s %s %q", severity, upParam.In, upParam.Name))
			continue
		}
		// Compare types.
		upType := schemaType(upParam.Schema)
		ourType := schemaType(ourParam.Schema)
		if upType != ourType {
			diffs = append(diffs, fmt.Sprintf("[param] type mismatch %s %q: upstream=%s ours=%s", upParam.In, upParam.Name, upType, ourType))
		}
	}

	// Parameters in ours but not upstream (extras — usually fine).
	for key, ourParam := range ourParams {
		if _, ok := upParams[key]; !ok {
			diffs = append(diffs, fmt.Sprintf("[param] extra %s %q (not in upstream)", ourParam.In, ourParam.Name))
		}
	}

	return diffs
}

// compareRequestBody compares request body schemas between upstream and ours.
func compareRequestBody(upstream, ours *openapi3.Operation) []string {
	upBody := upstream.RequestBody
	ourBody := ours.RequestBody

	if upBody == nil && ourBody == nil {
		return nil
	}
	if upBody == nil && ourBody != nil {
		return []string{"[request] we define a request body but upstream doesn't"}
	}
	if upBody != nil && ourBody == nil {
		return []string{"[request] MISSING request body (upstream defines one)"}
	}

	upSchema := getJSONSchema(upBody)
	ourSchema := getJSONSchema(ourBody)

	if upSchema == nil || ourSchema == nil {
		return nil
	}

	return compareSchemas(upSchema, ourSchema, "request")
}

// compareResponses compares the success response schemas between upstream and ours.
func compareResponses(upstream, ours *openapi3.Operation) []string {
	var diffs []string //nolint:prealloc // accumulated conditionally

	// Compare success status codes.
	upResp := getSuccessResponse(upstream.Responses)
	ourResp := getSuccessResponse(ours.Responses)

	if upResp == nil && ourResp == nil {
		return nil
	}
	if upResp == nil && ourResp != nil {
		return nil // We have a response, upstream doesn't define one — fine
	}
	if upResp != nil && ourResp == nil {
		return []string{"[response] MISSING response body (upstream defines one)"}
	}

	// Compare response body schema.
	upSchema := getResponseJSONSchema(upResp)
	ourSchema := getResponseJSONSchema(ourResp)

	if upSchema == nil || ourSchema == nil {
		return nil // Opaque response, can't compare
	}

	diffs = append(diffs, compareSchemas(upSchema, ourSchema, "response")...)
	return diffs
}

// compareSchemas compares two JSON object schemas, reporting missing/extra/mismatched properties.
func compareSchemas(upstream, ours *openapi3.Schema, prefix string) []string {
	var diffs []string

	if upstream == nil || ours == nil {
		return nil
	}

	// Compare top-level properties.
	upProps := upstream.Properties
	ourProps := ours.Properties

	// Track required fields in upstream.
	upRequired := make(map[string]bool)
	for _, r := range upstream.Required {
		upRequired[r] = true
	}

	// Properties in upstream but not in ours.
	for name := range upProps {
		if _, ok := ourProps[name]; !ok {
			severity := "missing"
			if upRequired[name] {
				severity = "MISSING"
			}
			diffs = append(diffs, fmt.Sprintf("[%s] %s property %q", prefix, severity, name))
		}
	}

	// Properties in ours but not upstream.
	for name := range ourProps {
		if _, ok := upProps[name]; !ok {
			diffs = append(diffs, fmt.Sprintf("[%s] extra property %q (not in upstream)", prefix, name))
		}
	}

	// Compare types of shared properties.
	for name, upRef := range upProps {
		ourRef, ok := ourProps[name]
		if !ok {
			continue
		}
		upType := schemaType(upRef)
		ourType := schemaType(ourRef)
		if upType != ourType {
			diffs = append(diffs, fmt.Sprintf("[%s] type mismatch property %q: upstream=%s ours=%s", prefix, name, upType, ourType))
		}
	}

	sort.Strings(diffs)
	return diffs
}

// schemaType returns a human-readable type description for a schema.
func schemaType(ref *openapi3.SchemaRef) string {
	if ref == nil {
		return "null"
	}
	s := ref.Value
	if s == nil {
		return "unresolved-ref"
	}

	if s.Type != nil && len(*s.Type) > 0 {
		t := (*s.Type)[0]
		switch t {
		case "array":
			if s.Items != nil {
				return "array<" + schemaType(s.Items) + ">"
			}
			return "array"
		case "object":
			if s.AdditionalProperties.Schema != nil {
				return "map<string," + schemaType(s.AdditionalProperties.Schema) + ">"
			}
			if len(s.Properties) > 0 {
				return "object"
			}
			return "object"
		default:
			if s.Format != "" {
				return t + "(" + s.Format + ")"
			}
			return t
		}
	}
	return "any"
}

// getJSONSchema extracts the JSON schema from a request body ref.
func getJSONSchema(body *openapi3.RequestBodyRef) *openapi3.Schema {
	if body == nil || body.Value == nil {
		return nil
	}
	ct := body.Value.Content.Get("application/json")
	if ct == nil || ct.Schema == nil {
		return nil
	}
	return ct.Schema.Value
}

// getResponseJSONSchema extracts the JSON schema from a response ref.
func getResponseJSONSchema(resp *openapi3.ResponseRef) *openapi3.Schema {
	if resp == nil || resp.Value == nil {
		return nil
	}
	ct := resp.Value.Content.Get("application/json")
	if ct == nil || ct.Schema == nil {
		return nil
	}
	return ct.Schema.Value
}

// getSuccessResponse returns the first 2xx response from a responses map.
func getSuccessResponse(responses *openapi3.Responses) *openapi3.ResponseRef {
	if responses == nil {
		return nil
	}
	m := responses.Map()
	// Try specific codes first.
	for _, code := range []string{"200", "201", "204"} {
		if r, ok := m[code]; ok {
			return r
		}
	}
	return nil
}

// collectEndpoints extracts "METHOD /path" strings from an OpenAPI spec.
func collectEndpoints(spec *openapi3.T) map[string]bool {
	set := make(map[string]bool)
	for path, pathItem := range spec.Paths.Map() {
		for method := range pathItem.Operations() {
			set[strings.ToUpper(method)+" "+path] = true
		}
	}
	return set
}

// categorizeEndpoint determines whether a spec endpoint is part of the core
// state backend protocol or an enterprise/SaaS feature we don't plan to implement.
func categorizeEndpoint(ep string) string {
	parts := strings.SplitN(ep, " ", 2)
	if len(parts) < 2 {
		return "NOT PLANNED: Unknown"
	}
	path := parts[1]

	// --- Top-level non-stacks APIs ---

	switch {
	case strings.HasPrefix(path, "/api/ai/"):
		return "NOT PLANNED: AI/Copilot"
	case strings.HasPrefix(path, "/api/esc/"):
		return "NOT PLANNED: ESC (Environments, Secrets, Config)"
	case strings.HasPrefix(path, "/api/console/"):
		return "NOT PLANNED: Console"
	case path == "/api/openapi":
		return "Core: OpenAPI spec"
	}

	// Organization management.
	if strings.HasPrefix(path, "/api/orgs/") || strings.HasPrefix(path, "/api/change-") {
		return categorizeOrgEndpoint(path)
	}

	// Extended user endpoints (beyond what CLI needs).
	if strings.HasPrefix(path, "/api/user/") {
		sub := path[len("/api/user/"):]
		switch {
		case sub == "stacks":
			return "Core: user stacks listing"
		case sub == "organizations/default":
			return "Core: user organizations"
		case strings.HasPrefix(sub, "organizations/"):
			return "NOT PLANNED: User Organizations (extended)"
		default:
			return "NOT PLANNED: User (extended — tokens, VCS, invites)"
		}
	}

	// Core endpoints.
	if path == "/api/capabilities" || strings.HasPrefix(path, "/api/cli/") {
		return "Core: capabilities/CLI"
	}
	if path == "/api/user" {
		return "Core: user"
	}

	// Stacks domain.
	if strings.HasPrefix(path, "/api/stacks/") {
		return categorizeStackEndpoint(parts[0], path)
	}

	return "NOT PLANNED: Other"
}

func categorizeOrgEndpoint(path string) string {
	matchers := []struct {
		contains string
		category string
	}{
		{"/teams", "NOT PLANNED: Teams"},
		{"/members", "NOT PLANNED: Org Members"},
		{"/roles", "NOT PLANNED: RBAC/Roles"},
		{"/deployments", "NOT PLANNED: Deployments (org-level)"},
		{"/search", "NOT PLANNED: Search/Insights"},
		{"/templates", "NOT PLANNED: Templates/Registry"},
		{"/webhooks", "NOT PLANNED: Webhooks (org-level)"},
		{"/audit-logs", "NOT PLANNED: Audit Logs"},
		{"/policygroups", "NOT PLANNED: Policy Groups"},
		{"/policypacks", "NOT PLANNED: Policy Packs"},
		{"/agents", "NOT PLANNED: Agents/Agent Pools"},
		{"/oidc", "NOT PLANNED: OIDC/Auth Policies"},
		{"/saml", "NOT PLANNED: SAML"},
		{"/cmk", "NOT PLANNED: Customer Managed Keys"},
		{"/tokens", "NOT PLANNED: Token Management"},
		{"change-gates", "NOT PLANNED: Change Gates"},
		{"change-requests", "NOT PLANNED: Change Requests"},
		{"/packages", "NOT PLANNED: Registry/Packages"},
	}
	for _, m := range matchers {
		if strings.Contains(path, m.contains) {
			return m.category
		}
	}
	return "NOT PLANNED: Organization (other)"
}

func categorizeStackEndpoint(method, path string) string {
	// /api/stacks/{org}/{proj}/{stack}/...
	segments := strings.Split(path, "/")
	// ["", "api", "stacks", "{org}", "{proj}", "{stack}", sub, ...]

	if len(segments) <= 6 {
		// /api/stacks/{org}, /api/stacks/{org}/{proj}, /api/stacks/{org}/{proj}/{stack}
		return "Core: stack CRUD"
	}

	sub := segments[6]
	switch sub {
	// --- Core update lifecycle ---
	case "preview", "update", "refresh", "destroy":
		if len(segments) > 8 {
			return categorizeUpdateSub(segments[8])
		}
		return "Core: update lifecycle"

	// --- Core state management ---
	case "export", "import":
		return "Core: export/import"
	case "encrypt", "batch-encrypt", "batch-decrypt":
		return "Core: secrets"
	case "decrypt":
		if len(segments) > 7 {
			// /decrypt/log-decryption, /decrypt/log-batch-decryption — audit logging
			return "NOT PLANNED: Decrypt Audit Logging"
		}
		return "Core: secrets"
	case "rename":
		return "Core: stack metadata"
	case "tags":
		if len(segments) > 7 || method == "POST" {
			// /tags/{tagName} or POST /tags — not used by CLI (CLI uses PATCH /tags)
			return "NOT PLANNED: Stack Tags (extended)"
		}
		return "Core: stack metadata"
	case "config":
		if method == "DELETE" {
			return "NOT PLANNED: Stack Config (extended)"
		}
		return "Core: stack metadata"
	case "updates":
		if len(segments) > 8 {
			sub2 := segments[8]
			switch sub2 {
			case "previews", "timeline", "summary":
				return "NOT PLANNED: Update Details (timeline/previews/summary)"
			}
		}
		return "Core: update history"

	// --- Enterprise features ---
	case "collaborators":
		return "NOT PLANNED: Stack Collaborators"
	case "drift":
		return "NOT PLANNED: Stack Drift"
	case "resources":
		return "NOT PLANNED: Stack Resources (insights)"
	case "activity":
		return "NOT PLANNED: Stack Activity"
	case "annotations":
		return "NOT PLANNED: Stack Annotations"
	case "webhooks":
		return "NOT PLANNED: Webhooks (stack-level)"
	case "notifications":
		return "NOT PLANNED: Stack Notifications"
	case "workflows":
		return "NOT PLANNED: Stack Workflows"
	case "deployments":
		return "NOT PLANNED: Deployments (stack-level)"
	case "metadata":
		return "NOT PLANNED: Stack Metadata (extended)"
	case "downstream-references":
		return "NOT PLANNED: Stack References"
	case "previews":
		return "NOT PLANNED: Stack Previews (extended)"
	case "timeline":
		return "NOT PLANNED: Stack Timeline"
	case "transfer":
		return "NOT PLANNED: Stack Transfer"
	default:
		return "NOT PLANNED: Stacks (other — " + sub + ")"
	}
}

func categorizeUpdateSub(sub string) string {
	switch sub {
	case "checkpoint", "checkpointverbatim", "checkpointdelta":
		return "Core: update checkpoints"
	case "journalentries":
		return "Core: journal entries"
	case "complete":
		return "Core: update lifecycle"
	case "events":
		return "Core: engine events"
	case "renew_lease":
		return "Core: lease renewal"
	case "cancel":
		return "Core: update cancel"
	case "log":
		return "NOT PLANNED: Update Logs"
	default:
		return "NOT PLANNED: Update (other — " + sub + ")"
	}
}
